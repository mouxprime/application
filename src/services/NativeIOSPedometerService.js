/**
 * Service de podom√®tre natif iOS utilisant CMPedometer
 * Fonctionne directement avec CoreMotion sans module natif
 */

import { Platform, NativeModules } from 'react-native';
import { Pedometer } from 'expo-sensors';

class NativeIOSPedometerService {
  constructor() {
    this.isAvailable = false;
    this.isActive = false;
    this.subscription = null;
    this.stepCallback = null;
    this.lastStepCount = 0;
    this.sessionStartTime = null;
    this.sessionStartSteps = 0;
    this.sessionStepCount = 0;
    this.firstCallbackReceived = false;
  }

  /**
   * Initialiser le service et v√©rifier la disponibilit√©
   */
  async initialize() {
    try {
      console.log('üçé [IOS-PEDOMETER] Initialisation du service CMPedometer...');
      
      if (Platform.OS !== 'ios') {
        console.log('üçé [IOS-PEDOMETER] Plateforme non iOS, service non disponible');
        this.isAvailable = false;
        return false;
      }

      // V√©rifier la disponibilit√© du podom√®tre
      const available = await Pedometer.isAvailableAsync();
      this.isAvailable = available;
      
      if (available) {
        console.log('‚úÖ [IOS-PEDOMETER] CMPedometer disponible');
        
        // Demander les permissions
        const { status } = await Pedometer.requestPermissionsAsync();
        if (status === 'granted') {
          console.log('‚úÖ [IOS-PEDOMETER] Permissions accord√©es');
          return true;
        } else {
          console.warn('‚ö†Ô∏è [IOS-PEDOMETER] Permissions refus√©es');
          this.isAvailable = false;
          return false;
        }
      } else {
        console.warn('‚ö†Ô∏è [IOS-PEDOMETER] CMPedometer non disponible sur cet appareil');
        return false;
      }
    } catch (error) {
      console.error('‚ùå [IOS-PEDOMETER] Erreur initialisation:', error);
      this.isAvailable = false;
      return false;
    }
  }

  /**
   * V√©rifier si le service est disponible
   */
  isServiceAvailable() {
    return this.isAvailable;
  }

  /**
   * D√©marrer le suivi des pas
   */
  async start(stepCallback) {
    try {
      if (!this.isAvailable) {
        throw new Error('Service CMPedometer non disponible');
      }

      if (this.isActive) {
        console.log('üçé [IOS-PEDOMETER] Service d√©j√† actif');
        return true;
      }

      console.log('üçé [IOS-PEDOMETER] D√©marrage du suivi des pas...');
      
      this.stepCallback = stepCallback;
      this.sessionStartTime = new Date();
      this.sessionStartSteps = 0;
      this.lastStepCount = 0;
      this.sessionStepCount = 0;
      this.firstCallbackReceived = false;

      console.log('üîÑ [IOS-PEDOMETER] R√©initialisation des compteurs de session');
      console.log(`üîÑ [IOS-PEDOMETER] lastStepCount: ${this.lastStepCount}`);
      console.log(`üîÑ [IOS-PEDOMETER] sessionStepCount: ${this.sessionStepCount}`);

      // D√©marrer le suivi en temps r√©el
      this.subscription = Pedometer.watchStepCount((result) => {
        this.handleStepUpdate(result);
      });

      this.isActive = true;
      console.log('‚úÖ [IOS-PEDOMETER] Service d√©marr√© avec succ√®s - Compteurs r√©initialis√©s');
      return true;

    } catch (error) {
      console.error('‚ùå [IOS-PEDOMETER] Erreur d√©marrage:', error);
      return false;
    }
  }

  /**
   * Arr√™ter le suivi des pas
   */
  stop() {
    try {
      if (this.subscription) {
        this.subscription.remove();
        this.subscription = null;
      }

      this.isActive = false;
      this.stepCallback = null;
      this.lastStepCount = 0;
      this.sessionStartTime = null;
      this.sessionStartSteps = 0;
      this.sessionStepCount = 0;
      this.firstCallbackReceived = false;

      console.log('üõë [IOS-PEDOMETER] Service arr√™t√© - Compteurs r√©initialis√©s');
    } catch (error) {
      console.error('‚ùå [IOS-PEDOMETER] Erreur arr√™t:', error);
    }
  }

  /**
   * R√©initialiser les compteurs de session
   */
  reset() {
    console.log('üîÑ [IOS-PEDOMETER] === R√âINITIALISATION COMPTEURS ===');
    console.log(`üîÑ [IOS-PEDOMETER] Avant reset - sessionStepCount: ${this.sessionStepCount}, lastStepCount: ${this.lastStepCount}`);
    
    this.sessionStartSteps = 0;
    this.lastStepCount = 0;
    this.sessionStepCount = 0;
    this.firstCallbackReceived = false;
    
    console.log(`üîÑ [IOS-PEDOMETER] Apr√®s reset - sessionStepCount: ${this.sessionStepCount}, lastStepCount: ${this.lastStepCount}`);
    console.log('üîÑ [IOS-PEDOMETER] === FIN R√âINITIALISATION ===');
  }

  /**
   * G√©rer les mises √† jour de pas
   */
  handleStepUpdate(result) {
    try {
      if (!this.stepCallback || !this.isActive) {
        return;
      }

      const currentTotalSteps = result.steps || 0;
      
      console.log(`üçé [IOS-PEDOMETER-DEBUG] === CALLBACK RE√áU ===`);
      console.log(`üçé [IOS-PEDOMETER-DEBUG] currentTotalSteps (syst√®me): ${currentTotalSteps}`);
      console.log(`üçé [IOS-PEDOMETER-DEBUG] sessionStartSteps: ${this.sessionStartSteps}`);
      console.log(`üçé [IOS-PEDOMETER-DEBUG] lastStepCount: ${this.lastStepCount}`);
      console.log(`üçé [IOS-PEDOMETER-DEBUG] sessionStepCount: ${this.sessionStepCount}`);
      console.log(`üçé [IOS-PEDOMETER-DEBUG] firstCallbackReceived: ${this.firstCallbackReceived}`);

      if (!this.firstCallbackReceived) {
        this.sessionStartSteps = currentTotalSteps;
        this.lastStepCount = currentTotalSteps;
        this.firstCallbackReceived = true;
        console.log(`üçé [IOS-PEDOMETER-DEBUG] PREMIER CALLBACK - sessionStartSteps initialis√© √†: ${this.sessionStartSteps}`);
        return;
      }

      const newStepsSinceLastCallback = currentTotalSteps - this.lastStepCount;
      
      console.log(`üçé [IOS-PEDOMETER-DEBUG] newStepsSinceLastCallback: ${newStepsSinceLastCallback}`);

      if (newStepsSinceLastCallback > 0) {
        this.sessionStepCount += newStepsSinceLastCallback;
        
        console.log(`üçé [IOS-PEDOMETER] Nouveaux pas d√©tect√©s: ${newStepsSinceLastCallback}`);
        console.log(`üçé [IOS-PEDOMETER] Total session: ${this.sessionStepCount} pas`);
        console.log(`üçé [IOS-PEDOMETER] Total syst√®me: ${currentTotalSteps} pas`);

        const stepLength = this.getEstimatedStepLength();
        
        const distance = newStepsSinceLastCallback * stepLength;
        const dx = distance;
        const dy = 0;

        this.stepCallback({
          stepCount: newStepsSinceLastCallback,
          stepLength: stepLength,
          dx: dx,
          dy: dy,
          timestamp: Date.now(),
          totalSteps: this.sessionStepCount,
          confidence: 0.95,
          source: 'ios_cmpedometer',
          nativeStepLength: stepLength,
          averageStepLength: stepLength,
          cadence: this.calculateCadence(newStepsSinceLastCallback),
          timeDelta: 1000,
          isFallback: false
        });

        this.lastStepCount = currentTotalSteps;
        
        console.log(`üçé [IOS-PEDOMETER-DEBUG] lastStepCount mis √† jour: ${this.lastStepCount}`);
      }
      
      console.log(`üçé [IOS-PEDOMETER-DEBUG] === FIN CALLBACK ===`);

    } catch (error) {
      console.error('‚ùå [IOS-PEDOMETER] Erreur traitement pas:', error);
    }
  }

  /**
   * Obtenir une estimation de la longueur de pas
   */
  getEstimatedStepLength() {
    // Essayer d'obtenir la longueur de pas du profil utilisateur
    try {
      const { userProfileService } = require('./UserProfileService');
      if (userProfileService && userProfileService.isProfileComplete()) {
        const stepLength = userProfileService.getStepLength();
        if (stepLength > 0) {
          return stepLength;
        }
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è [IOS-PEDOMETER] Impossible d\'obtenir la longueur de pas du profil');
    }

    // Valeur par d√©faut
    return 0.75; // 75 cm par pas
  }

  /**
   * Calculer la cadence (pas par minute)
   */
  calculateCadence(newSteps) {
    if (!this.sessionStartTime) {
      return 0;
    }

    const elapsedMinutes = (Date.now() - this.sessionStartTime.getTime()) / (1000 * 60);
    if (elapsedMinutes > 0) {
      return Math.round((this.lastStepCount + newSteps) / elapsedMinutes);
    }

    return 0;
  }

  /**
   * Obtenir les statistiques du service
   */
  getStats() {
    return {
      isAvailable: this.isAvailable,
      isActive: this.isActive,
      platform: 'ios',
      service: 'CMPedometer',
      lastStepCount: this.lastStepCount,
      sessionStartTime: this.sessionStartTime,
      sessionStartSteps: this.sessionStartSteps
    };
  }

  /**
   * Obtenir les donn√©es de pas pour une p√©riode
   */
  async getStepCountForPeriod(startDate, endDate) {
    try {
      if (!this.isAvailable) {
        throw new Error('Service non disponible');
      }

      const result = await Pedometer.getStepCountAsync(startDate, endDate);
      console.log(`üçé [IOS-PEDOMETER] Pas pour la p√©riode: ${result.steps}`);
      
      return {
        steps: result.steps || 0,
        startDate: startDate,
        endDate: endDate
      };

    } catch (error) {
      console.error('‚ùå [IOS-PEDOMETER] Erreur r√©cup√©ration donn√©es p√©riode:', error);
      return {
        steps: 0,
        startDate: startDate,
        endDate: endDate,
        error: error.message
      };
    }
  }
}

// Instance singleton
export const nativeIOSPedometerService = new NativeIOSPedometerService(); 